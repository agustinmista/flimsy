:thunk ones
take 10 ones
:thunk ones
val ones = 1 :> ones
case 4 of 3 => 3
10
10
print 10
:e lib/prelude.fl 
:e lib/prelude.fl 
(left [1,2,3], false)
show (left [1,2,3], false)
show (left [1,2,3], false)
show (left [1,2,3])
show (left 10)
show (take 2 [1,2,3,x])
show (take 2 [1,2,3,x])
show (take 2 [1,2,3,x])
show [1,2,3,x]
[1,2,3,x]
val x = x
show [1,2,3]
show [1,2,3]
show (1,2,x)
val x = x
show [1,2,3]
show (10, 20)
show (10, 20)
show (10, 20)
:t show (10, 20)
:t show 10
show 10
:t show
:t show
show true
:e lib/prelude.fl 
ones
val ones = 1 :> ones
ones
take 5 ones
val ones = 1 :> ones
take 5 ones
ones
val ones = 1 :> ones
take 2 [1,2,3,bad,5]
val bad = bad
x
val x = x
take 2 [1,2,3,4,5]
:thunk bad
val bad = [1,2,3,4,5,6, bottom]
:thunk bad
take 2 bad
take 2 bad
val bad = [1,2,3,4,5,6, bottom]
take 2 bad
val bad = [1,2,3,4,5,6, bottom]
bad
val bad = [1,2,3,4,5,6, bottom]
take 2 bad
val bad = [1,2,3,4,5,6, bottom]
take 2 [1,2,3,4,5,6, bottom]
:e lib/prelude.fl 
:browse lib/prelude.fl 
:e lib/prelude.fl 
:browse lib/prelude.fl 
take 2 [1,2,3,4,5,6, bottom]
bottom 
bot
take 2 [1,3, let val f = f in f end]
let val f = f in f end
let val f = f in f
let f = f in f
take 2 [1,3,4]
take 2 [1,3,4]
take 2 [1,3,4]
take 2 [1,3,4]
take 2 [1,3,4]
take 2 [1,3,4]
take 2 [1,3,4]
take 2 [1,3,4]
take 2 [1,3,4]
take 2 [1,3,4]
[1,3,4]
(10,20)
10 + 20
case ones of | [x,y|xs] => [x,y]
case (1,ones) of | (x, y) => 5
val ones = 1 :: ones
case (1,ones) of | (x, y) => 5
val ones = 1 :: ones
bad
case (1,bad) of | (x, y) => 5
case (1,bad) of | (x, y) => x
val bad = bad
case (1,bad) of | (x, y) => x
case (1,bad) of | (x, y) => x
val bad = bad
case (1,bad) of | (x, y) => x
case (1,bad) of | (x, y) => x
