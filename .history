:t zip
zip [] []
:e lib/Prelude.fl 
zip [] []
:e lib/Prelude.fl 
zip
:t  zip
:t zipWith
:t zipWith getline
:t getline
:echo filter (fn x => x == 10)
:echo 2 + 2
:echo
1 :: []
:t do { putstr "foo\n" } 
do { putstr "foo\n" } 
do { putstr "foo" } 
2 + 2
take 25 xs
take 25' xs
take 20 xs
take 100 xs
take 10 xs
val xs = 1 :: map (fn n => n * 2) xs
take 10 xs
val xs = 1 :: map (fn n => n + 1) xs
xs <- 0 :: map (fn n => n + 1) xs
xs = 0 :: map (fn n => n + 1) xs
let xs = 1 :: map (fn n => n + 1) xs
filter (fn x => fst x == 10) [(10, "aa"), (20, "bb"), (10, "cc")]
:t filter (fn x => fst x == 10) [(10, "aa"), (20, "bb"), (10, "cc")]
:t filter (fn x => fst x == 10)
:t filter (fn x => fst x == 10) [10, 20,30,40,10,20]
:t filter (fn x => x == 10) [10, 20,30,40,10,20]
:t filter (fn x => x == 10)
filter (fn x => x == 10)
filter (fn x => x > 10)
1.0 ./ 2.0
1 ./ 2
(1, bottom) == (2, "foo")
val bottom = bottom
val bottom = botton
botom
(1+3) == (2+2)
1 == (2+2)
:t (==)
1 == "foo"
1 == 2
1 == 1
1/0
filter (fn x => case x of | 1 => false | _ => true) [1,2,3,1,1,2,3,4]
:t filter (fn x => case x of | 1 => false | _ => true)
filter (fn x => case x of | 1 => false | _ => true)
:l fl/Test.fl 
:browse Prelude
:browse Prelude
:l fl/Test.fl 
:l fl/Test.fl 
:l lib/Prelude.fl 
:browse Prelude
:browse Test
:l fl/Test.fl 
:l fl/Test.fl 
:e fl/Test.fl 
:l fl/Test.fl 
:! mv fl/test.fl fl/Test.fl
:l fl/test.fl 
:e fl/test.fl 
:l fl/test.fl 
:e fl/test.fl 
fun fib x = x + 2
:browse Prelude
main
odd 30
:browse OddEven
:browse 
:l fl/OddEven.fl 
even 30
even 30
odd 30
foo 
bar
:br OddEven
:l fl/OddEven.fl 
bar
odd 10
even 10
foo
:l fl/OddEven.fl 
:l fl/OddEven.fl 
:l fl/OddEven.fl 
:l fl/OddEven.fl 
:l fl/OddEven.fl 
bar
odd 30
even 30
:l fl/OddEven.fl 
even 30
odd 30
:l fl/OddEven.fl 
