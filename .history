1.0 ./ 2.0
1 ./ 2
(1, bottom) == (2, "foo")
val bottom = bottom
val bottom = botton
botom
(1+3) == (2+2)
1 == (2+2)
:t (==)
1 == "foo"
1 == 2
1 == 1
1/0
filter (fn x => case x of | 1 => false | _ => true) [1,2,3,1,1,2,3,4]
:t filter (fn x => case x of | 1 => false | _ => true)
filter (fn x => case x of | 1 => false | _ => true)
:l fl/Test.fl 
:browse Prelude
:browse Prelude
:l fl/Test.fl 
:l fl/Test.fl 
:l lib/Prelude.fl 
:browse Prelude
:browse Test
:l fl/Test.fl 
:l fl/Test.fl 
:e fl/Test.fl 
:l fl/Test.fl 
:! mv fl/test.fl fl/Test.fl
:l fl/test.fl 
:e fl/test.fl 
:l fl/test.fl 
:e fl/test.fl 
fun fib x = x + 2
:browse Prelude
main
odd 30
:browse OddEven
:browse 
:l fl/OddEven.fl 
even 30
even 30
odd 30
foo 
bar
:br OddEven
:l fl/OddEven.fl 
bar
odd 10
even 10
foo
:l fl/OddEven.fl 
:l fl/OddEven.fl 
:l fl/OddEven.fl 
:l fl/OddEven.fl 
:l fl/OddEven.fl 
bar
odd 30
even 30
:l fl/OddEven.fl 
even 30
odd 30
:l fl/OddEven.fl 
:l fl/OddEven.fl 
:l fl/OddEven.fl 
:l fl/OddEven.fl 
:l fl/OddEven.fl 
odd 10
bar
foo
:l fl/OddEven.fl 
:l fl/OddEven.fl 
:l fl/OddEven.fl 
:l fl/OddEven.fl 
bar
:t bar
:t even 
:t :t even
:t odd
odd 2
:l fl/OddEven.fl 
:l fl/OddEven.fl 
:l fl/OddEven.fl 
:l fl/OddEven.fl 
:l fl/OddEven.fl 
:t main
:browse Do
:l fl/Do.fl 
:browse A Prelude
:browse A
:l fl/B.fl 
foo
:l fl/A.fl 
take 10 nats
val nats = 0 :: map (fn x => x + 1) nats 
:load fl/B.fl 
:browse A
:load fl/A.fl 
:browse Prelude
10
